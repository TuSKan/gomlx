package main

import (
	"fmt"
	"github.com/gomlx/gomlx/internal/cmd/backends_generator/parsexlabuilder"
	"github.com/gomlx/gomlx/types"
	"github.com/gomlx/gomlx/types/xslices"
	"github.com/janpfeifer/must"
	"go/ast"
	"os"
	"os/exec"
	"slices"
	"strings"
	"text/template"
)

const (
	standardOpsInterfaceFile = "gen_standard_ops.go"
)

// methodsToExclude from generating the API, they are maintained manually,
// or simply excluded (deprecated methods).
var methodsToExclude = types.SetWith(
	"BatchNormForInference", "BatchNormForTraining", "BatchNormGradient",
	"And", "Or", "Xor", "Not", "ReduceAnd", "ReduceOr", "ReduceXor", "ScatterAdd")

var (
	standardOpsTemplate = template.Must(template.New(standardOpsInterfaceFile).Parse(`
/***** File generated by ./internal/cmd/backends_generator, based on github.com/gomlx/gopjrt. Don't edit it directly. *****/

package backends

import (
	"github.com/gomlx/gomlx/types/shapes"
	"github.com/gomlx/gopjrt/dtypes"
)

type StandardOps interface { {{range .}}
{{range .Comments}}	// {{.}}
{{end}}	{{.Name}}({{range .Parameters}}{{.Names}} {{.Type}},{{end}}) (Op, error)
{{end}}}
`))
)

type FuncInfo struct {
	Name       string
	Parameters []*ParamInfo
	Comments   []string
}

type ParamInfo struct {
	Names, Type string
}

func selectAndScatterComments(funcName string) []string {
	aggregation := funcName[len(funcName)-3:]
	return []string{
		funcName + " runs windows (similar to ReduceWindow) over the operand, selects values to updates the output (like ScatterAdd)",
		"It selects the values in the window such that it works as reverse for a Pool" + aggregation + " operation.",
		"See details in https://openxla.org/xla/operation_semantics#selectandscatter",
	}
}

// GenerateStandardOpsInterface generates the interface for the various standard ops.
// The rest of the ops are maintained manually.
func GenerateStandardOpsInterface(extractor *parsexlabuilder.NodeTextExtractor, xlaBuilderPkg *ast.Package) {
	var standardOps []FuncInfo
	parsexlabuilder.EnumerateStandardOpsFunctions(extractor, xlaBuilderPkg, func(funcDecl *ast.FuncDecl) {
		if methodsToExclude.Has(funcDecl.Name.Name) {
			return
		}
		var params []*ParamInfo
		for _, param := range funcDecl.Type.Params.List {
			if param.Names[0].Name == "builder" {
				// builder is not needed by the API, since the builder is given by the object implementing the interface.
				continue
			}
			names := xslices.Map(param.Names, func(ident *ast.Ident) string { return ident.Name })
			pi := &ParamInfo{
				Names: strings.Join(names, ", "),
				Type:  extractor.Get(param.Type),
			}
			if pi.Type == "*Op" {
				pi.Type = "Op"
			} else if pi.Type == "...*Op" {
				pi.Type = "...Op"
			} else if pi.Type == "[]*Op" {
				pi.Type = "[]Op"
			} else if pi.Type == "Shape" {
				pi.Type = "shapes.Shape"
			} else if pi.Type == "xla_data.FftType" {
				pi.Type = "FFTType"
			}
			params = append(params, pi)
		}
		fi := FuncInfo{
			Name: funcDecl.Name.Name,
			Comments: slices.DeleteFunc(
				strings.Split(funcDecl.Doc.Text(), "\n"),
				func(s string) bool {
					return s == "" || s == "The op is created on the same XlaBuilder as used for x." ||
						strings.Index(s, "ScatterCustom") != -1
				}),
			Parameters: params,
		}
		if strings.HasPrefix(fi.Name, "SelectAndScatter") {
			fi.Comments = selectAndScatterComments(fi.Name)
		}
		standardOps = append(standardOps, fi)
	})
	slices.SortFunc(standardOps, func(a, b FuncInfo) int { return strings.Compare(a.Name, b.Name) })

	fileName := standardOpsInterfaceFile
	f := must.M1(os.Create(fileName))
	must.M(standardOpsTemplate.Execute(f, standardOps))
	must.M(f.Close())

	cmd := exec.Command("gofmt", "-w", fileName)
	fmt.Printf("\t%s\n", cmd)
	must.M(cmd.Run())
	fmt.Printf("\t\tgenerated %q based on github.com/gomlx/gopjrt/xlabuilder\n", fileName)
}
